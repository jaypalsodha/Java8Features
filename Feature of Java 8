
										java 8 Features
------------------------------------------------------------------------------------------------

1. Lambda Expression:- 
	defination:- It is an anonymous function. 
		- nameless
		- without return type
		- without modifier

	benefits:- It is used to enable functional programming.

	let see how to write lambda expression:-

	suppose we have an method

	public void doSomething()
	{
		System.out.println("hello");
	}

	As per the defination lambda expression doesn't contains name, return type and modifier. 

	so just remove all these things from above method. 

	()
	{
		System.out.println("hello");	
	}

	to represent lambda expression they provide one special symbol called -> (arrow) is used.

	() ->
	{
		System.out.println("hello");	
	}

	here, curly braces is the body of an method.

	() ->{System.out.println("hello");}

	If method body contains only one line of code, then {} becomes optional.


	example 2:- 
	using java 7 :- 
	public void m1(int a, int b)
	{
		System.out.println(a+b);
	}

	using lambda expression. 

	(a,b)-> System.out.println(a+b);

	example 3:- 
	
	using java 7 
	public int squareIt(int n)
	{
		return n*n;
	}
	using lambda expression

	(int n)-> {return n*n;}
	Or
	(int n)-> n*n; //without brackets you don't need to specify return keyword 
	Or
	(n) -> n*n; // if only one argument is there,then paranthesis is also not needed
	or
	n -> n*n; // if body contain only one line the curly braces are not needed.



	public void m1(String s)
	{
		return s.length();
	}

	using lambda expression

	s -> s.length();

	without curly braces we cannot use return statement
	within curly braces if we want to return some value then we must have to use return statement. 


	Once we write lambda expressions.

	Functional Interface

		- Functional interface is an interface which contains single abstract method(SAM).


	
	Functional Interface with respect to Inheritance

	-----------------------------------------------------------------------------------
	@FunctionalInterface
	interface A
	{
		public void m1();

	}
	@FunctionalInterface	
	interface B extends A
	{

	}

	above example is perfectly valid. . 

	----------------------------------------------------------------------------------
	@FunctionalInterface
	interface A
	{
		public void m1();

	}
	@FunctionalInterface	
	interface B extends A
	{
		public void m1(); /// overriding concept is there, so its valid
	}

	--------------------------------------------------------------------------------
	@FunctionalInterface
	interface A
	{
		public void m1();

	}
	@FunctionalInterface	
	interface B extends A
	{
		public void m2(); /// Child interface contains two abstract methods
	}

	--------------------------------------------------------------------------------
	@FunctionalInterface
	interface A
	{
		public void m1();

	}
	//@FunctionalInterface	 removed annotation, so it is valid
	interface B extends A
	{
		public void m2(); /// valid because its normal interface
	}	

	---------------------------------------------------------------------------------



	Lambda expression for Multi Threading

	Lambda expression with Collections class

	Use Lambda expression for our own class.

	Anonymous inner class is more power full than lambda expression. 


	as lambda expression can only be used with only functional interface. 

	but anonymous inner class can be used for both the cases.


Default Methods:- 
	- 1.8 version onwards we can take default methods inside interface. 
	- untill 1.7v every method present inside interface always ::: public and abstract.
	- in 1.8 version default methods and static method allowed.
	- in 1.9 version private methods are also allowed.
	- every variable present inside interface is always public static final. 

Default Method | Virtual Extension Method | Defender Method :-
	- without affecting implementation classes. 
	- without affecting implementation classes if we want to add new method to the interface, we can use default method. 


	Example for default method:::::


		interface Left
		{
			default void m1(){
				System.out.println("Left Interface Method");
			}
		}
		interface Right
		{
			default void m1(){
				System.out.println("Right interface Method");
			}	
		}

		class Test implements Left, Right
		{
			public void m1()
			{
				System.out.println("implementing method m1");
			}
			public static void main(String[] args) {
				Test t = new Test();
				t.m1();
			}
		}

		here if we remove method m1() from the implementing class(i.e Test Class) then code
		won't compile, because there are same default methods in Left and Right method, so
		which method to call.


Main purpose of Default method inside interface:- 
	- without affecting implementation classes, If we want to add new method to the interface.


To define general utility method inside interface with static method.

static methods are not directly available to the imlementation classes. 

we have to call that method using interface Name. 	
	


Predefined Functional Interfaces:- 
---------------------------------------------------------------------------------------------
 - Predicate
 - Function
 - Consumer
 - Supplier


Two argument predefined Functional Interfaces:- 
---------------------------------------------------------------------------------------------
 - BiPredicate
 - BiFunction
 - BiConsumer

primitive Functional Interfaces:- 
---------------------------------------------------------------------------------------------
 - IntPredicate
 - IntFunction
 - IntConsumer  


Predicate(I):- functional interface
 - Predicate functional interface is mainly use to check conditional checks.
 - single parameter is allowed for predicate function.
 - Type of parameter can be any datatype like Integer, float, double, or any object type.
 - we use lambda expression to write our condtion inside the predicate.
 - example
 	interface Predicate<T>
 	{
 		public abstract boolean test(T t);
 	}

 - to check the boolean condition then we can go for Predicate function.

 	Example for Predicate use:- 

		import java.util.function.Predicate;
		class Test
		{
			public static void main(String[] args) {
				
				//using p
				Predicate<Integer> p = i ->i%2==0;
				System.out.println(p.test(10));
				
				System.out.println();

				Predicate<String> p1 = s ->s.equals("jaypal") || s.equals("sodha");
				System.out.println(p1.test("jaypal"));
				System.out.println(p1.test("sodha"));

				Employee emp = new Employee("karan",24);
				Predicate<Employee> empPredicate = namePara -> namePara.name.equals("jaypal sodha");

				Predicate<Employee> agePredicate = agePara -> agePara.age.equals(24);
				System.out.println(empPredicate.test(emp));
				System.out.println(agePredicate.test(emp));

			}
		}

		class Employee
		{
			String name;
			Integer age;

			Employee(String name, Integer age){
				this.name = name;
				this.age = age;
			}
		}

Predicate joining:- 
 - we can join two predicate condition together using "and" and "or" method present in predicate functional interface.
 - we can also use negate() method to get the reverse result of predicate condition.		


Function (Predefined Functional interaface):- 
 
 example:- 

 interface Function<T,R>
 {
 	public abstract R apply(T t);
 }

	import java.util.function.*;
	class FunctionDemo
	{
		public static void main(String[] args) {
			
			Function<String,String> f = s->s.toUpperCase();
			System.out.println(f.apply("jaypal"));
		}	
	}


---------------------------------------------------------------------------------------
import java.util.function.*;

class Student
{
	String name;
	int marks;
	Student(String name, int marks)
	{
		this.name = name;
		this.marks = marks;
	}
}
class FunctionDemo
{
	public static void main(String[] args) {
		
		Student[] s = new Student[5];
		s[0] = new Student("rajesh",96);
		s[1] = new Student("hitesh",10);
		s[2] = new Student("rajes",50);
		s[3] = new Student("rajes",66);
		s[4] = new Student("rajes",76);

		Function<Student,String> fun = student->
		{
			int marks = student.marks;
			String grade = "";
			if(marks > 80) grade = "A[Distinction]";
			else if(marks > 60) grade = "B[First Class]";
			else if(marks > 50) grade = "C[Second Class]";
			else if(marks > 35) grade = "D[Third Class]";
			else grade = "E[Failed]";
			return grade;
		};

		for(Student s1 : s){
			System.out.println("Student name :"+ s1.name);
			System.out.println("Student marks :"+ s1.marks);
			System.out.println("Student grade :"+ fun.apply(s1));
			System.out.println();
		}
	}	
}
--------------------------------------------------------------------------------------


function chaining:- 

f1.andThen(f2).apply(i);

first f1 and then f2 will be applied

--------------------------------------------------------------------------------------

import java.util.function.*;

class FunctionDemo
{
	public static void main(String[] args) {
		
		Function<Integer,Integer> f1 = i-> 2*i;
		Function<Integer,Integer> f2 = i-> i*i*i;

		System.out.println(f1.andThen(f2).apply(2));  //64
		System.out.println(f1.compose(f2).apply(2));  //16
		
	}
}
---------------------------------------------------------------------------------------