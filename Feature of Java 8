
										java 8 Features
------------------------------------------------------------------------------------------------

1. Lambda Expression:- 
	defination:- It is an anonymous function. 
		- nameless
		- without return type
		- without modifier

	benefits:- It is used to enable functional programming.

	let see how to write lambda expression:-

	suppose we have an method

	public void doSomething()
	{
		System.out.println("hello");
	}

	As per the defination lambda expression doesn't contains name, return type and modifier. 

	so just remove all these things from above method. 

	()
	{
		System.out.println("hello");	
	}

	to represent lambda expression they provide one special symbol called -> (arrow) is used.

	() ->
	{
		System.out.println("hello");	
	}

	here, curly braces is the body of an method.

	() ->{System.out.println("hello");}

	If method body contains only one line of code, then {} becomes optional.


	example 2:- 
	using java 7 :- 
	public void m1(int a, int b)
	{
		System.out.println(a+b);
	}

	using lambda expression. 

	(a,b)-> System.out.println(a+b);

	example 3:- 
	
	using java 7 
	public int squareIt(int n)
	{
		return n*n;
	}
	using lambda expression

	(int n)-> {return n*n;}
	Or
	(int n)-> n*n; //without brackets you don't need to specify return keyword 
	Or
	(n) -> n*n; // if only one argument is there,then paranthesis is also not needed
	or
	n -> n*n; // if body contain only one line the curly braces are not needed.



	public void m1(String s)
	{
		return s.length();
	}

	using lambda expression

	s -> s.length();

	without curly braces we cannot use return statement
	within curly braces if we want to return some value then we must have to use return statement. 


	Once we write lambda expressions.

	Functional Interface

		- Functional interface is an interface which contains single abstract method(SAM).


	
	Functional Interface with respect to Inheritance

	-----------------------------------------------------------------------------------
	@FunctionalInterface
	interface A
	{
		public void m1();

	}
	@FunctionalInterface	
	interface B extends A
	{

	}

	above example is perfectly valid. . 

	----------------------------------------------------------------------------------
	@FunctionalInterface
	interface A
	{
		public void m1();

	}
	@FunctionalInterface	
	interface B extends A
	{
		public void m1(); /// overriding concept is there, so its valid
	}

	--------------------------------------------------------------------------------
	@FunctionalInterface
	interface A
	{
		public void m1();

	}
	@FunctionalInterface	
	interface B extends A
	{
		public void m2(); /// Child interface contains two abstract methods
	}

	--------------------------------------------------------------------------------
	@FunctionalInterface
	interface A
	{
		public void m1();

	}
	//@FunctionalInterface	 removed annotation, so it is valid
	interface B extends A
	{
		public void m2(); /// valid because its normal interface
	}	

	---------------------------------------------------------------------------------



	Lambda expression for Multi Threading

	Lambda expression with Collections class

	Use Lambda expression for our own class.

	Anonymous inner class is more power full than lambda expression. 


	as lambda expression can only be used with only functional interface. 

	but anonymous inner class can be used for both the cases.


Default Methods:- 
	- 1.8 version onwards we can take default methods inside interface. 
	- untill 1.7v every method present inside interface always ::: public and abstract.
	- in 1.8 version default methods and static method allowed.
	- in 1.9 version private methods are also allowed.
	- every variable present inside interface is always public static final. 

Default Method | Virtual Extension Method | Defender Method :-
	- without affecting implementation classes. 
	- without affecting implementation classes if we want to add new method to the interface, we can use default method. 


	Example for default method:::::


		interface Left
		{
			default void m1(){
				System.out.println("Left Interface Method");
			}
		}
		interface Right
		{
			default void m1(){
				System.out.println("Right interface Method");
			}	
		}

		class Test implements Left, Right
		{
			public void m1()
			{
				System.out.println("implementing method m1");
			}
			public static void main(String[] args) {
				Test t = new Test();
				t.m1();
			}
		}

		here if we remove method m1() from the implementing class(i.e Test Class) then code won't compile, because there are same default methods in Left and Right method, so which method to call.

		
	
